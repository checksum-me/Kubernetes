Entire course is available here -> https://github.com/kodekloudhub/certified-kubernetes-security-specialist-cks-course/tree/main/docs

###Kubelet Security
#Kubelet will run as a service or if setup via Kubeadm then the config file will have the config details
#Kubelet Service location -> /usr/local/bin/kubelet in /etc/systemd/system/kube-apiserver.service
#Kubelet config file -> /var/lib/kubelet/kubelet-config.yaml

#Kubelet Port Access
10250 - Serves API that allows full Access
10255 - Serves API that allows unauthenticated read Access

curl -sk https://localhost:10250/pods/
curl -sk https://localhost:10250/logs/syslog
curl -sk http://localhost:10255/metrics

#Set the below to false in the config file
--anonymous-auth=false
#otherwise the above urls will allow anyone to read the kubelet status

#Kubelet support two authentication mechanism - Certificate based and Bearer token based

#For certificate based authentication
--client-ca-file=/path/to/ca.crt or clientCAFile: /path/to/ca.crt

#Default kubelet allows all requests from API server without auth, to set auth use auth-mode to Webhook as below
#When set kubelet authorises req via kube-apiserver
--authorization-mode=Webhook or authorization: mode: Webhook

#Read only port by default is set to 10255 which enables to read metrics server without auth, set to 0 to disable this as below
--read-only-port=0 or readOnlyPort: 0

#Check kubelet config file
ps -aux | grep kubelet

#Kubelet config needs to be edited to change auth mode
vi /var/lib/kubelet/config.yaml
#This is one setting
authentication:
  anonymous:
    enabled: false
#Once above change is done, you should get Unauthorized
controlplane ~ âžœ  curl -sk https://localhost:10250/pods
Unauthorized

#This is another setting
authorization:
  mode: Webhook
#Once above change is done, it will not allow to connect as anonymous

#This is another setting
#Set readOnlyPort as 0 in /var/lib/kubelet/config.yaml and restart kubelet
#The metrics URL wont work

#Restart kubelet service to take effect 
systemctl restart kubelet.service
systemctl status kubelet.service

curl -sk https://localhost:10250/pods
curl -sk http://localhost:10255/metrics

###Kubectl Proxy and Port forward
kubectl proxy - Opens proxy port to API server
kubectl port-forward - Opens port to target deployment pods
##Kubectl Proxy
#The below command starts a proxy server to the API server - default port is 8001
#Once the proxy server is started, we can connect to it using curl command locally via localhost
#To run the process in background you can use & operator at the end

kubectl proxy &
#To run on a different port
kubectl proxy --port 8002 &
curl 127.0.0.1:8001/version

##Port forward
#Port from out laptop 28080 is forwarded to the 80 port of the service
kubectl port-forward service/nginx 28080:80
kubectl port-forward pod/nginx-77d8468669-52jpx 8005:80 &
#The below command can access the service
curl http://localhost:28080/

###Kubernetes Dashboard
#View and create new apps. Can do anything
#To access in local laptop create proxy and open the below link if dashboard is setup in cluster
kubectl proxy
#Open below link in browser
https://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy

#Since the dashboard is clusterip its not accessible outside cluster
#Can be made loadbalancer or nodeport

##Dashboard authentication
#Can use Token or KubeConfig file
#For token , create user and assign RBAC permission, generate token and enter in website

#Run below command to create dashboard
kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml

#Now run kubectl proxy with the below command 
kubectl proxy --address=0.0.0.0 --disable-filter &

#Note: From a security perspective do not use --disable-filter option as it can leave you vulnerable to XSRF attacks, when used with an accessible port. We have used this option to make our lab environment work with the kubernetes dashboard so you can access it through a browser. Ideally you would be accessing it through a kubectl proxy on your localhost only.
#So in actual environments do not use --disable-filter option as its a major security risk.

#Get token by running below and login to UI with that token:
kubectl get secrets -n kubernetes-dashboard admin-user -o go-template="{{.data.token | base64decode}}"

#Below are some references:
https://redlock.io/blog/cryptojacking-tesla
https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/
https://github.com/kubernetes/dashboard
https://www.youtube.com/watch?v=od8TnIvuADg 
https://blog.heptio.com/on-securing-the-kubernetes-dashboard-16b09b1b7aca
https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md

###Verify the platform binaries
#Important to verify hash of the downloaded file

#Download file using curl command
curl https://dl.k8s.io/v1.20.0/kubernetes.tar.gz -L -o kubernetes.tar.gz
#Verify the files hash generated from below command with the one is download page
#shasum generates hash for the downloaded file
shasum -a 512 kubernetes.tar.gz #MacOS
sha512sum kubernetes.tar.gz #Linux

#To decompress a file
cd /opt/
tar -xf kubernetes.tar.gz
#Make some changes
cd kubernetes
echo "v1.30.0-modified" > version
cd ..
#compress the directory again
tar -czf kubernetes-modified.tar.gz kubernetes
shasum -a512 kubernetes-modified.tar.gz

###Below are some references for kubernetes versioning and different releases
https://github.com/kubernetes/kubernetes/releases
https://github.com/kubernetes/design-proposals-archive/blob/main/release/versioning.md
https://github.com/kubernetes/design-proposals-archive/blob/main/api-machinery/api-group.md
https://blog.risingstack.com/the-history-of-kubernetes/
https://kubernetes.io/docs/setup/version-skew-policy

###Kubernetes upgrade in controlplane and worker nodeport

###Network policies

###Ingress and how to setup the same 

###Configuring docker service

systemctl start docker 
systemctl status docker 
systemctl stop docker 
#configuring the service loads it up automatically when the system loads up
#Also can be loaded manually in foreground using dockerd
dockerd --debug
#This is for troubleshooting docker. --debug adds more details

#when docker starts it listens to internal unix socket at /var/run/docker.sock
#Unix socket is for IPC - Inter Process Communication 
# Used for communication between different processes on the same host
#docker.sock is only accessible from docker CLI on the same host
#standard port for docker is 2375

dockerd --debug --host=tcp://192.168.1.10:2375
#the host will make docker available on the mentioned IP
#need to be extremely careful while doing this as this exposes docker outside of host. mght allow anyone on the internet to run containers on this host
#docker default setting is its not encrypted and no authentication is required

#In the another host export a DOCKER_HOST and then you can access docker as below
export DOCKER_HOST="tcp://192.168.1.10:2375"
docker ps
#default is unencrypted traffic

#To enable encryption set tls to true and add certificates
dockerd --debug \
        --host=tcp://192.168.1.10:2376 #Note 2376 is the secure https port compared to 2375 unencrypted port
        --tls=true \
        --tlscert=/var/docker/server.pem \
        --tlskey=/var/docker/serverkey.pem

#move config to a json file at /etc/docker/daemon.json
{
  "debug": true,
  "hosts": ["tcp://192.168.1.10:2376]
  "tls": true,                              #Only enables encryption does not enforce TLS authentication
  "tlscert": "/var/docker/server.pem",
  "tlskey": "/var/docker/serverkey.pem"
  "tlsverify": true,                        #This is configured to enforce TLS authentication
  "tlscacert": "/var/docker/caserver.pem"   #This is configured to enforce TLS authentication
}

#once config file is provided no need to pass options in the command dockerd
#These options are passed through in the docker via background also via systemctl
#In the client machine place the certs in ./docker users home directory or pass in the CLI

###Debugging a crashed API server
https://github.com/kodekloudhub/community-faq/blob/main/docs/diagnose-crashed-apiserver.md

###Securing controlplane and etcd 
#Restrict communication between etcd and api server to the cipher TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 and also restrict the api server minimum TLS version to TLS 1.2
#Edit the API server manifest and add the following two arguments
--tls-min-version=VersionTLS12
--tls-cipher-suites=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
#Edit the etcd manifest and add the following argument
--cipher-suites=TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
#Wait for both pods to restart. This may take a minute or more.


